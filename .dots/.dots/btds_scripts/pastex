#!/usr/bin/env python3
# @pastex file: pastex
# @pastex version: 3.0.0
# @pastex change: FIXED CRITICAL BUG. Execution is now OPT-IN only. Added mandatory Diff/Confirm loop.

import os
import sys
import subprocess
import shutil
import re
import difflib
from pathlib import Path

# --- CONFIGURATION ---
MANDATORY_HEADERS = ["file", "version", "change"]
MAX_HEADER_SCAN_LINES = 50

def log(level, msg):
    colors = {"INFO": "\033[94m", "OK": "\033[92m", "WARN": "\033[93m", "ERR": "\033[91m"}
    print(f"{colors.get(level, '')}>> [{level}] {msg}\033[0m")

def parse_chunk_metadata(lines):
    meta = {}
    for line in lines[:MAX_HEADER_SCAN_LINES]:
        line = line.strip()
        if not line.startswith("# @pastex"): continue
        try:
            _, raw = line.split("@pastex", 1)
            if ":" in raw:
                key, val = raw.split(":", 1)
                meta[key.strip()] = val.strip()
        except ValueError: continue
    return meta

def generate_file_content(lines, meta):
    content = []
    if "shebang" in meta:
        content.append(f"#!{meta['shebang']}")
    for line in lines:
        if not line.strip().startswith("# @pastex"):
            content.append(line)
    return "\n".join(content) + "\n"

def process_chunk(chunk):
    lines = chunk.splitlines()
    meta = parse_chunk_metadata(lines)
    
    # 1. Validation
    missing = [h for h in MANDATORY_HEADERS if h not in meta]
    if missing:
        if "file" in meta: log("ERR", f"Skipping {meta['file']}: Missing headers {missing}")
        return

    filename = meta["file"]
    version = meta["version"]
    change = meta["change"]
    
    # 2. Target Resolution
    if "target" in meta:
        target_path = Path(meta["target"]).expanduser().resolve()
    else:
        target_path = Path.home() / ".local" / "bin" / "btds" / filename
        
    new_text = generate_file_content(lines, meta)

    # 3. Auditor Loop (Diff & Confirm)
    if target_path.exists():
        try:
            with open(target_path, 'r') as f: old_text = f.read()
        except: old_text = "[Binary/Read Error]"

        if old_text != new_text:
            print(f"\n[AUDIT] Proposed Change: {filename} (v{version})")
            print(f"Goal: {change}")
            print(f"Target: {target_path}")
            
            diff = difflib.unified_diff(
                old_text.splitlines(), new_text.splitlines(),
                fromfile=f"CURRENT", tofile=f"INCOMING (v{version})", lineterm=''
            )
            for line in diff:
                if line.startswith('+'): print(f"\033[92m{line}\033[0m")
                elif line.startswith('-'): print(f"\033[91m{line}\033[0m")
                else: print(line)

            if input(f"Overwrite {filename}? [y/N]: ").strip().lower() != 'y':
                log("WARN", "Aborted by user.")
                return
        else:
            log("INFO", f"No changes for {filename}. Checking exec...")

    # 4. Write
    try:
        target_path.parent.mkdir(parents=True, exist_ok=True)
        with open(target_path, "w") as f: f.write(new_text)
        target_path.chmod(0o755)
        log("OK", f"Deployed {filename} v{version}")
    except Exception as e:
        log("ERR", f"Write failed: {e}")
        return

    # 5. EXECUTION (OPT-IN ONLY)
    if "exec" in meta:
        cmd = meta["exec"].replace("%f", str(target_path))
        print(f"\n[EXEC] Request: {cmd}")
        if input("Execute this command? [y/N]: ").strip().lower() == 'y':
            subprocess.call(cmd, shell=True)
        else:
            log("WARN", "Execution skipped.")

def main():
    if "--version" in sys.argv:
        print(f"pastex v3.0.0-SOVEREIGN")
        sys.exit(0)
    
    try:
        content = None
        for cmd in ["termux-clipboard-get", "wl-paste", "xclip -o"]:
            if shutil.which(cmd.split()[0]):
                try: 
                    content = subprocess.check_output(cmd.split(), text=True)
                    break
                except: continue
        
        if not content:
            log("ERR", "Clipboard empty/unavailable.")
            sys.exit(1)

        p_header = "# " + "@pastex file:"
        chunks = re.split(f'(?={p_header})', content)
        valid = [c for c in chunks if p_header in c]

        if not valid:
            log("WARN", "No '@pastex file:' headers found.")
            sys.exit(1)

        log("INFO", f"Processing {len(valid)} file(s)...")
        for chunk in valid: process_chunk(chunk.strip())

    except Exception as e:
        log("ERR", f"Fatal: {e}")
        sys.exit(1)

if __name__ == "__main__": main()
